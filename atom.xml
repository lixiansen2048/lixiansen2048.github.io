<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>初学者</title>
  
  <subtitle>平凡的平淡</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lixiansen2048.github.io/"/>
  <updated>2019-08-11T04:52:41.788Z</updated>
  <id>https://lixiansen2048.github.io/</id>
  
  <author>
    <name>李艳祥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode第 215 题：数组中的第 k 个最大元素</title>
    <link href="https://lixiansen2048.github.io/2019/08/11/QSort/"/>
    <id>https://lixiansen2048.github.io/2019/08/11/QSort/</id>
    <published>2019-08-11T05:00:38.000Z</published>
    <updated>2019-08-11T04:52:41.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速选择算法解决数组中的第-k-个最大元素"><a href="#快速选择算法解决数组中的第-k-个最大元素" class="headerlink" title="快速选择算法解决数组中的第 k 个最大元素"></a>快速选择算法解决数组中的第 k 个最大元素</h1><hr><h3 id="题目来源：LeetCode-第-215-题"><a href="#题目来源：LeetCode-第-215-题" class="headerlink" title="题目来源：LeetCode 第 215 题"></a>题目来源：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">LeetCode 第 215 题</a></h3><p>这道题有三个解法,都是力扣官方题解提供的，我首先想到的前两种，但觉得有点投机取巧，因为是直接调用的python内置函数，一句话就能搞定。力扣官方提供第三种解法，利用经典的快速排序算法的一种变形解决。因为基础不牢，我看了很长时间才弄明白,所以打算写下来加深理解。文章主要介绍第三种解法：</p><blockquote><ol><li><strong>排序：</strong> 先对数组进行排序，然后直接返回倒数第 k 个元素，python中直接使用语句 <code>sorted(nums)[-k]</code> 求出最后结果。算法的时间复杂度为 O(NlogN)，空间复杂度为O(1)</li><li><strong>堆：</strong> 创建一个大顶堆，将数组的元素加入到堆中，并保证堆的大小小于等于 k，然后堆中就保留了前 k 个最大元素，这样，堆顶元素就是正确答案。python中有内置的该方法直接求出堆的前 k个最大元素，语句<code>heapq.nlargest(k, nums)[-1]</code>，就可得出最后结果。时间复杂度 : O(Nlogk)，空间复杂度 : O(k)，用于存储堆元素</li></ol></blockquote><h3 id="快速选择算法："><a href="#快速选择算法：" class="headerlink" title="快速选择算法："></a>快速选择算法：</h3><p>快速选择的思路与快速排序一致，选择一个元素作为基准对数组进行分区，使得基准左侧的元素都小于基准的值，右侧的元素都大于基准的值，不同的是，快速选择并不递归访问双边，而是递归到一侧寻找，这使得平均时间复杂度由 O(NlogN) 降低到O(N)。</p><h4 id="python-实现快速排序，分而治之-递归"><a href="#python-实现快速排序，分而治之-递归" class="headerlink" title="python 实现快速排序，分而治之+递归"></a>python 实现快速排序，分而治之+递归</h4><p>对基准两侧分别进行递归操作。选择基准，并申请额外的两个空间，遍历数组，将小于枢轴的元素加入到 left 数组，大于基准的元素加入到 right 数组。</p><p>快速排序代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""QuickSort"""</span>      <span class="token comment" spellcheck="true"># entry and exit  </span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">:</span>                 <span class="token comment" spellcheck="true"># select an element as the pvoit</span>        povit <span class="token operator">=</span> data<span class="token punctuation">[</span>len<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span>               <span class="token comment" spellcheck="true"># define the list to the left and right of the pvoit </span>        left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>          <span class="token comment" spellcheck="true"># remove the povit from the origin list </span>        data<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>povit<span class="token punctuation">)</span>                <span class="token keyword">for</span> num <span class="token keyword">in</span> data<span class="token punctuation">:</span>                        <span class="token keyword">if</span> num <span class="token operator">>=</span> povit<span class="token punctuation">:</span>                                right<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>                        <span class="token keyword">else</span><span class="token punctuation">:</span>                                left<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>                <span class="token keyword">return</span> quick_sort<span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">[</span>povit<span class="token punctuation">]</span> <span class="token operator">+</span> quick_sort<span class="token punctuation">(</span>right<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> data<span class="token comment" spellcheck="true"># example：</span>array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>quick_sort<span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output = [1, 2, 2, 3, 4, 5, 5, 6, 7, 7, 9, 9, 10, 12, 15, 15, 17]</span></code></pre><h4 id="python-实现快速选择算法"><a href="#python-实现快速选择算法" class="headerlink" title="python 实现快速选择算法"></a>python 实现快速选择算法</h4><p>对基准的一侧进行递归，寻找第 k 个最大的元素。代码中 partition() 函数作用是对数组进行分区，通过以下三步实现：</p><ol><li>将基准移到最右侧；</li><li>将小于基准的数移到 pivot_fix 的左侧；</li><li>将基准移回 pivot_fix 的位置。</li></ol><p>最后该函数返回分区后基准的位置。将位置返回到select()函数中之后，判断该位置是否为 k_smallest(即 len(nums) - k),若是，则返回，若大于 k_smallest，则遍历基准的左侧部分数组，重复之前操作，反之，则遍历基准右侧部分数组，重复之前操作。</p><p>力扣第 215 题解题代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: int        """</span>        <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> pivot_index<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># the value of pivot</span>            pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>pivot_index<span class="token punctuation">]</span>            <span class="token comment" spellcheck="true"># move the pivot to the right of nums</span>            nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>pivot_index<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>pivot_index<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span>            pivot_fix <span class="token operator">=</span> left            <span class="token comment" spellcheck="true"># move the smaller than the value of pivot to the left</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>pivot_fix<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>pivot_fix<span class="token punctuation">]</span>                    pivot_fix <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># move the pivot to the original index</span>            nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>pivot_fix<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>pivot_fix<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span>            <span class="token keyword">return</span> pivot_fix        <span class="token keyword">def</span> <span class="token function">select</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> k_smallest<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token triple-quoted-string string">"""            Returns the k-th smallest element of list within left..right            """</span>            <span class="token keyword">if</span> left <span class="token operator">==</span> right<span class="token punctuation">:</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>            <span class="token comment" spellcheck="true"># select pviot</span>            pivot_index <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>            pivot_index <span class="token operator">=</span> partition<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">,</span>pivot_index<span class="token punctuation">)</span>            <span class="token keyword">if</span> pivot_index <span class="token operator">==</span> k_smallest<span class="token punctuation">:</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>pivot_index<span class="token punctuation">]</span>            <span class="token comment" spellcheck="true"># do left</span>            <span class="token keyword">elif</span> pivot_index <span class="token operator">></span> k_smallest<span class="token punctuation">:</span>                <span class="token keyword">return</span> select<span class="token punctuation">(</span>left<span class="token punctuation">,</span>pivot_index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>k_smallest<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># do right</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> select<span class="token punctuation">(</span>pivot_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>k_smallest<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># kth largest is (n - k)th smallest</span>        <span class="token keyword">return</span> select<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> k<span class="token punctuation">)</span>res <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>output <span class="token operator">=</span> res<span class="token punctuation">.</span>findKthLargest<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span></code></pre><p><em>【完】</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速选择算法解决数组中的第-k-个最大元素&quot;&gt;&lt;a href=&quot;#快速选择算法解决数组中的第-k-个最大元素&quot; class=&quot;headerlink&quot; title=&quot;快速选择算法解决数组中的第 k 个最大元素&quot;&gt;&lt;/a&gt;快速选择算法解决数组中的第 k 个最大元素&lt;/
      
    
    </summary>
    
      <category term="leetcode 题解" scheme="https://lixiansen2048.github.io/categories/leetcode-%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="python 3" scheme="https://lixiansen2048.github.io/tags/python-3/"/>
    
      <category term="数组" scheme="https://lixiansen2048.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="排序" scheme="https://lixiansen2048.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>一本叫 《骆驼祥子》 的书</title>
    <link href="https://lixiansen2048.github.io/2019/07/29/mood1/"/>
    <id>https://lixiansen2048.github.io/2019/07/29/mood1/</id>
    <published>2019-07-29T12:46:38.000Z</published>
    <updated>2019-07-29T12:46:56.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="祥子：一个时代的牺牲者"><a href="#祥子：一个时代的牺牲者" class="headerlink" title="祥子：一个时代的牺牲者"></a>祥子：一个时代的牺牲者</h1><hr><pre class=" language-1"><code class="language-1">这本书是老舍在七七事变那一年写成的，一九四五年，此书在美国被译成英文，但将末端删去了，把悲剧的下场改为了大团圆，以便迎合美国读者的心理。</code></pre><p>&emsp;&emsp;祥子的故事从骆驼说起，自己的新车转眼间变成了三匹骆驼这让祥子很不甘心，他想要一辆自己的车！祥子的命运始终和车绑在一起，几经沉浮，祥子自己也体会到了人在社会身不由己，生活可不像拉车这么容易。穷人的梦想也只能是梦想，最后祥子向生活妥协，堕落……</p><p>&emsp;&emsp;有人说 《骆驼祥子》 是在讲：</p><blockquote><ul><li>无产阶级被资产阶级压榨的故事</li><li>个人主义在中国如何行不通的故事</li><li>平凡人的努力不一定能够成功的故事</li></ul></blockquote><p>&emsp;&emsp;对于我而言，《骆驼祥子》 也有我们影子。</p><p>&emsp;&emsp;祥子的感受就是我的感受。祥子第一次攒够钱买到车时，我欢喜。他为了多攒几块钱冒险拉车而被抢了车时，我懊悔。他被别人欺负时，我生气。“人为刀俎，我为鱼肉”就是这类社会底层人的真实写照，善良、简单、诚实的祥子一次次被生活暴击，活着看似很痛苦。</p><p>&emsp;&emsp;前段时间读余华的《活着》， 为福贵的悲惨命运难受了一阵子。他们都是在生活越来越有奔头的时候遭受重大打击，上天总是给了他们很多希望，然后又摧毁他们的希望。不一样的是福贵在一次次得失中看淡了命运的不公，平凡的度过余生，而祥子却放弃了自己，行尸走肉般活着。</p><blockquote><p>好吧，老实，规矩，要强，既然都没有用，变成这样的无赖也不错</p></blockquote><p>&emsp;&emsp;他活成了自己最讨厌的样子。<br>&emsp;&emsp;他的人生起起落落，一次次重拾希望，又一次次遭受希望破灭的打击，让人看着也跟着揪心。<br>&emsp;&emsp;好不容易攒够了钱买了车，被抢走了；再次攒钱买车，还没攒够，钱被骗走了；娶了老婆，老婆难产而死。车没了，家没了，一切又回到原点。他堕落了很长一段时间，最后打起精神要好好生活，去找曹先生，曹先生为他安排好工作，也答应为他心上人小福子安排吃住，这是他最后燃起的希望。他满心欢喜地期待着把小福子接过来。他回到之前的小院，却怎么也找不到小福子，多方打听之后才知道她被父亲卖到了妓院，等他找到那个妓院后，小福子已经自杀了。小福子的自杀，使他丧失了所有的期待和幻想，他再也不敢期盼未来，再也没有动力去追逐理想的生活，再也不愿付出努力了。他还活着，但心已经死了，空留着一副皮囊苟活于世。<br>&emsp;&emsp;想毁掉一个人太简单了，只要让他的梦想不断地破灭即可。</p><blockquote><p>穷人的命，他似乎看明白了，是枣核儿的两头尖：幼小的时候能不饿死，万幸；到老了能不饿死，很难。只有中间的一段，年轻力壮，不怕饥饱劳碌，还能像个人儿似的。</p></blockquote><p>&emsp;&emsp;老舍的比喻总是那么精确，只言片语便道出了那个时期底层人民的状态。年轻力壮总是好过的，童年和老年就是两个最无奈的时期。没有生存的能力，又不能忍受饥饱劳碌。社会在变化，就如今而言，这个比喻也相当贴切。把人生比作枣核，枣核两头尖代表人生的童年和老年，真正有深度有意义的还是枣核的中间部分，年轻力壮，大有可为。但人总是在最好时光做自己后悔的事，或者说在自己无力与时光相耗时，又难掩悲伤。</p><blockquote><p>爱与不爱，穷人得在金钱上决定，“情种”只生在大富之家</p></blockquote><p>&emsp;&emsp;钱不是万能的，但对于穷人来说，钱几乎就是生活的全部，或者说穷人的生活是围着钱转的。有金钱作为基础，爱情或许才会更美好。</p><h3 id="《骆驼祥子》-经典语句摘录："><a href="#《骆驼祥子》-经典语句摘录：" class="headerlink" title="《骆驼祥子》 经典语句摘录："></a>《骆驼祥子》 经典语句摘录：</h3><blockquote><ol><li>苦人的懒是努力而落了空的自然结果，苦人的耍刺儿含着一些公理</li><li>人间的真话本来不多，一个女子的脸红胜过一大片话</li><li>爱与不爱，穷人得再金钱上决定，“情种”只生在大富之家</li><li>越不肯努力便越自怜</li><li>懒，能使人脾气变大</li><li>经验是生活得肥料，有什么样得经验便变成什么样的人，在沙漠里养不出牡丹来</li><li>在不准知道事情的吉凶的时候，人总是先往好里想</li><li>为个人努力的也知道如何毁灭个人，这是个人主义的两端</li><li>乱世的热闹来自迷信，愚人的安慰只有自欺</li><li>懂行的人得到个便宜，就容易忘掉东西买到手有没有好处</li><li>什么也是假的，只有钱是真的</li><li>常将有日思无日，莫到无时盼有时</li><li>一个人仿佛根本什么都不是，只是一只鸟，自己去打食，便会落到网里。吃人家的粮米，便得老老实实地在笼子里，给人家啼唱，而随时可以被人卖掉</li><li>一个天真的，发自内心的笑，仿佛把以前的困苦全一笔勾销，而笑着换个新的世界，像换一件衣服那么容易，痛快</li><li>最伟大的牺牲时忍辱，最伟大的忍辱时预备反抗</li><li>苦人是容易死的，苦人死了是容易被人忘掉的</li><li>疲乏之后的安息是最甜美的享受</li></ol></blockquote><p><em>【完】</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;祥子：一个时代的牺牲者&quot;&gt;&lt;a href=&quot;#祥子：一个时代的牺牲者&quot; class=&quot;headerlink&quot; title=&quot;祥子：一个时代的牺牲者&quot;&gt;&lt;/a&gt;祥子：一个时代的牺牲者&lt;/h1&gt;&lt;hr&gt;
&lt;pre class=&quot; language-1&quot;&gt;&lt;code c
      
    
    </summary>
    
      <category term="随笔" scheme="https://lixiansen2048.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="读书" scheme="https://lixiansen2048.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>边充电边玩手机会爆炸么</title>
    <link href="https://lixiansen2048.github.io/2019/07/29/phone1/"/>
    <id>https://lixiansen2048.github.io/2019/07/29/phone1/</id>
    <published>2019-07-29T04:33:38.000Z</published>
    <updated>2019-07-29T05:44:59.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="边玩手机边充电真的会爆炸么"><a href="#边玩手机边充电真的会爆炸么" class="headerlink" title="边玩手机边充电真的会爆炸么"></a>边玩手机边充电真的会爆炸么</h1><hr><blockquote><p><strong>结论</strong> ： 使用正规充电器，手机边玩边充电发生爆炸的几率几乎为零。需要注意的是：第一、充电尽量使用原装充电器。第二、不随意搭配充电设备。第三、充电环境温度要适宜。第四、及时清理充电口。第五、尽量不要边玩边充电。</p></blockquote><h3 id="手机爆炸是怎么发生的"><a href="#手机爆炸是怎么发生的" class="headerlink" title="手机爆炸是怎么发生的"></a>手机爆炸是怎么发生的</h3><p>我们通常说的边玩手机边充电、边打电话边充电会发生危险，一般都是指电池的爆炸。</p><blockquote><ol><li>从手机充电的电路设计角度来看，在充电过程中使用手机，手机运行程序所需的电能来源于电源而非电池，这时电池充电跟手机的使用是分开的，互不影响。</li><li>电池充满电后，会停止充电。并且由于电池端电压小于外接电路的电压，电池也不会放电。</li><li>充电状态下的手机可以作为一个正常的电器使用，一般不会发生爆炸，<strong>使用正规充电器，手机边玩边充电发生爆炸的几率几乎为零。</strong>但是如果使用的是劣质或者山寨的充电器，很有可能因为质量不过关，出现手机电路不稳定，造成电池异常发热，导致手机有可能发生爆炸。</li></ol></blockquote><p>大家可能经常从电视上或者新闻中，看到不少因为边充电边玩手机的原因而导致手机爆炸的问题，其实这个问题和电池是没有关系的，主要还是因为充电时使用了不匹配的充电器，或者是第三方充电器。更有甚者，是手机在出厂时，电池就有问题，存在着安全隐患，一般情况下是不会有这种事情发生的。</p><h3 id="怎样充电更安全"><a href="#怎样充电更安全" class="headerlink" title="怎样充电更安全"></a>怎样充电更安全</h3><blockquote><ol><li><strong>充电尽量使用原装充电器。</strong>非原装充电器可能会出现手机充电缓慢、损坏电池的情况。如果使用劣质充电器，还有可能造成安全隐患。</li><li><strong>不随意搭配充电设备。</strong>充电器与USB充电线混用，很可能会导致充电速度变慢，无法给手机充电的情况。为手机充电时建议选择与手机电流适配的充电设备进行充电。</li><li><strong>充电环境温度要适宜。</strong>在低温环境下，锂电池的低温保护机制会使得手机电池不发生化学反应，从而导致充电缓慢的情况发生。温度过高的环境中充电很可能会损失锂电池，造成安全隐患。</li><li><strong>及时清理充电口。</strong>充电口长时间暴露在外面，会产生灰尘堆积，导致手机充电接触不良，影响充电速度。记得定期清洁手机充电口，一笔米娜出现灰尘堵塞。</li><li><strong>尽量不要边玩边充电。</strong>边玩边充电会加剧手机发热。手机长时间处于这种状态，会导致手机寿命急剧缩短，严重时甚至会引发火灾。如果必须边玩边充电，应注意观察手机的情况，一旦出现高温异常，应立即停止操作。</li></ol></blockquote><p><em>【完】</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;边玩手机边充电真的会爆炸么&quot;&gt;&lt;a href=&quot;#边玩手机边充电真的会爆炸么&quot; class=&quot;headerlink&quot; title=&quot;边玩手机边充电真的会爆炸么&quot;&gt;&lt;/a&gt;边玩手机边充电真的会爆炸么&lt;/h1&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;
      
    
    </summary>
    
      <category term="随笔" scheme="https://lixiansen2048.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="手机" scheme="https://lixiansen2048.github.io/tags/%E6%89%8B%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第 46 题：全排列</title>
    <link href="https://lixiansen2048.github.io/2019/07/23/79th/"/>
    <id>https://lixiansen2048.github.io/2019/07/23/79th/</id>
    <published>2019-07-23T02:33:38.000Z</published>
    <updated>2019-07-23T06:49:16.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-回溯法专题"><a href="#LeetCode-回溯法专题" class="headerlink" title="LeetCode 回溯法专题"></a>LeetCode 回溯法专题</h1><hr><h3 id="题目来源：LeetCode-第-46-题"><a href="#题目来源：LeetCode-第-46-题" class="headerlink" title="题目来源：LeetCode 第 46 题"></a>题目来源：<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">LeetCode 第 46 题</a></h3><blockquote><p><strong>回溯法</strong> 是一种在探索尝试的过程中来找出所有解的算法。当确定这个候选解不满足求解条件时，就’回溯’返回，尝试其他路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术就叫回溯法。</p></blockquote><h6 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h6><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">permute</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: List[List[int]]        """</span>        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index <span class="token operator">==</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>                output<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">return</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token operator">not</span> used<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    p<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>                    backtrack<span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span>                    used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>                    p<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        output <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        used <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span> <span class="token operator">*</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        backtrack<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> output</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode-回溯法专题&quot;&gt;&lt;a href=&quot;#LeetCode-回溯法专题&quot; class=&quot;headerlink&quot; title=&quot;LeetCode 回溯法专题&quot;&gt;&lt;/a&gt;LeetCode 回溯法专题&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;题目来源：LeetCod
      
    
    </summary>
    
      <category term="leetcode 题解" scheme="https://lixiansen2048.github.io/categories/leetcode-%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="回溯法" scheme="https://lixiansen2048.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
      <category term="python 3" scheme="https://lixiansen2048.github.io/tags/python-3/"/>
    
      <category term="数组" scheme="https://lixiansen2048.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
