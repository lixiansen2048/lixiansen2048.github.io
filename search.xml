<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《哪吒》</title>
      <link href="/2019/08/16/mood2/"/>
      <url>/2019/08/16/mood2/</url>
      
        <content type="html"><![CDATA[<h1 id="哪吒：去他的鸟命"><a href="#哪吒：去他的鸟命" class="headerlink" title="哪吒：去他的鸟命"></a>哪吒：去他的鸟命</h1><hr><p>&emsp;&emsp;我去电影院的次数屈指可数，动漫电影今天是第一次，看完《哪吒之魔童降世》，如果用三个字评价观影感受那就是：不后悔。电影上映差不多有20天了，我看之前也是有些了解的，大概剧情是什么也知道了，但看别人的文字描述真不如现身处地的看感受的真切，更能说服自己发自内心的感叹一声：当之无愧的国产优秀动漫电影。<br><img src="https://greaterr.gitee.io/picture/p2563815625.jpg" alt="哪吒之魔童降世"></p><h2 id="不一样的故事"><a href="#不一样的故事" class="headerlink" title="不一样的故事"></a>不一样的故事</h2><p>&emsp;&emsp;“天地灵气孕育出一颗能量巨大的混元珠，元始天尊将混元珠提炼成灵珠和魔丸，灵珠投胎为人，助周伐纣时可堪大用；而魔丸则会诞出魔王，为祸人间。元始天尊启动了天劫咒语，3年后天雷将会降临，摧毁魔丸。太乙受命将灵珠托生于陈塘关李靖家的第三个儿子身上，并取名哪吒。然而阴差阳错，灵珠和魔丸竟然被申公豹掉包，灵珠转世成了敖丙，而本应是灵珠英雄的哪吒却成了魔童。”说起敖丙，龙族在影片中扮演的角色也很悲催，并非是掌管东海，说是龙宫，实为天牢，龙族是为了镇压在海底的上古神兽而存在，且不得离开海底半步，相当于也把龙族囚禁在了海底，实际上在百姓眼中就是如此，龙族也被视为妖怪。龙王为了能够离开海底“天牢”，联合申公豹，想培育出优秀的后人建功立业，于是便有了申公豹盗取灵珠，并注入到龙蛋中。敖丙便成了灵珠转世。说起魔丸转世的哪吒，一出生便魔性大发，伤人无数，幸得太乙用乾坤圈镇压其魔性，虽如此也已然被关中百姓贴上了标签：妖怪。<br><img src="https://greaterr.gitee.io/picture/p2563815624.jpg" alt="龙王与申公豹"></p><p>&emsp;&emsp;生来就被贴上“妖怪”的标签，被人当作异类，而父母每天在外降妖除魔，整天不着家，哪吒过的好不开心。想和其他人好好相处，但总被排斥，被当作妖怪？那就当作妖怪给他们看，四处捣蛋的哪吒最终被关在家中，后来被太乙带到山河社稷图中修炼，但目标不明，怎么会努力，他可不想像他们所说的为了以后保护那些无知可恨的百姓而修炼，等到父母诓其说他是灵珠转世，只是百姓不知道而已之后，才静下心来修炼，后来在追妖怪之时与敖丙相遇，并成为朋友。但这次经历更是加深了哪吒与百姓的误会，妖怪海夜叉逃跑时顺带捉走一小女孩，一群不明真相的吃瓜群众非要说是哪吒所为，以至于哪吒再次被关入家中，而此时也距离哪吒3岁生辰没几天了，而生辰那日便是天雷降临之日。李靖夫妇便想为哪吒举办生辰宴，并挨家挨户请求都来参加，哪吒兴奋至极，立刻画下地图，前往东海，吹起海螺，召唤敖丙，邀其参加生辰宴。<br><img src="https://greaterr.gitee.io/picture/p2563815623.jpg" alt="入魔后的哪吒"><br>&emsp;&emsp;另一方面，申公豹也另有打算。申公豹告诉哪吒他的真实身份，并授予解开乾坤的口诀，最后哪吒在生辰宴上解开口诀化身为魔，万夫莫敌，正在危机时刻，敖丙前来相救，之后哪吒被乾坤圈重新镇压，哪吒怨恨父母延期真相，遂飞走不见，后来在太乙坐骑的提示下哪吒了解到李靖为了为其解开天雷劫，竟打算将天雷引致自己身上，后悔莫及，便飞回陈塘关。话说敖丙帮助重新压制了哪吒的魔性之后，龙族身份被发现，被百姓们大骂，贬为妖怪，敖丙气不过，便水淹陈塘关，幸得哪吒前来解救，化为半魔的哪吒打败敖丙，但并未杀他，因为他是哪吒唯一的朋友，敖丙深受感动，随后天雷便至，敖丙与哪吒共同抵御天雷劫，灵珠魔丸又重合一体，在太乙的帮助下，虽未保住哪吒和敖丙的肉身，但魂魄却得以保留。此番经历，完全改变了哪吒在百姓心中的地位，成为了小英雄。</p><p><img src="https://greaterr.gitee.io/picture/p2563658635.jpg" alt="哪吒大战敖丙"><br>&emsp;&emsp;故事改编的很精彩，最泪目的便是哪吒与敖丙结成朋友一起踢毽子，混世魔王哪吒激动大哭和哪吒告别父母，敖丙陪哪吒抵御天雷劫，太感动了，呜呜……</p><h2 id="走心的台词"><a href="#走心的台词" class="headerlink" title="走心的台词"></a>走心的台词</h2><p>&emsp;&emsp;不得不说的是影片中的原创台词，趣味无穷，又引人深思。赋闲在家，被人喊成妖怪吐槽：“我是小妖怪，逍遥又自在，杀人不眨眼，吃人不放盐，一口七八个，肚皮要撑破，茅房去拉屎，想起忘带纸。”接地气。捉了妖怪却被误会“生活你全是泪，没死就得活受罪，越是折腾越倒霉，越有追求越悲催，垂死挣扎你累不累，不如瘫在床上睡。来来回回千百遍，小爷也是很疲倦。”是嘛！越折腾越倒霉，越有追求越悲催，好真实。<br>&emsp;&emsp;“我命由我不由天，是魔是仙，我是谁只有我自己说了算。”<br>&emsp;&emsp;“别人的看法都是狗屁，你是谁只有你自己说了才算，这是爹教我的道理。”<br>&emsp;&emsp;“如果你问我，人能否改变自己的命运，我也不晓得，但是不认命，就是哪吒的命。”<br>&emsp;&emsp;“人心中的成见是一座大山，任你怎么努力都休想搬动。”<br>&emsp;&emsp;“生而孤独，从不认命；逆天而行，斗到底！”<br>&emsp;&emsp;“若命运不公，就和它斗到底。”</p><p><em>【完】</em></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第 3 题：无重复字符的最长子串</title>
      <link href="/2019/08/11/sliding-window/"/>
      <url>/2019/08/11/sliding-window/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口解无重复字符的最长字串"><a href="#滑动窗口解无重复字符的最长字串" class="headerlink" title="滑动窗口解无重复字符的最长字串"></a>滑动窗口解无重复字符的最长字串</h1><hr><h3 id="题目来源：LeetCode-第-3-题"><a href="#题目来源：LeetCode-第-3-题" class="headerlink" title="题目来源：LeetCode 第 3 题"></a>题目来源：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">LeetCode 第 3 题</a></h3><blockquote><p><strong>滑动窗口</strong> 是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 <code>[i, j]</code> 向右滑动 1 个元素，则它将变为 <code>[i+1, j+1]</code>。</p></blockquote><h3 id="滑动过程："><a href="#滑动过程：" class="headerlink" title="滑动过程："></a>滑动过程：</h3><p>滑动窗口左右两边界均是闭的，最开始滑动窗口里没有元素，即 <code>left = 0,right = -1</code>，res 用来存储最长窗口的长度，初始为 0。移动窗口，窗口向右判断下一个元素是否已存在于窗口内，如果不存在，则将该元素加入到窗口中，即 <code>right + 1</code>,左边界不动。如果窗口内已经存在该元素，则将该元素加入到窗口中，即 <code>right + 1</code> ，同时将窗口左边界移到窗口中已存在的元素的位置，即 <code>left + 1</code> 直到窗口中重复元素的位置为止。重复上述步骤。在窗口滑动的过程中，每得到一个新的窗口，都将与 res 中的值比较，res 中始终存放的是之前所有窗口的最长长度。</p><h3 id="判断元素在窗口中是否已经存在"><a href="#判断元素在窗口中是否已经存在" class="headerlink" title="判断元素在窗口中是否已经存在"></a>判断元素在窗口中是否已经存在</h3><p>通过计算频率的方法判断是否已经存在，python 中使用 collection 中的 defaultdict 类来存放窗口中每个元素的频率。每向窗口中加入一个元素，则该元素的频率设为 1 ，每去掉一个元素，则将移除元素的频率重置为 0 ，所以窗口中每个元素的频率都为 1，若下一个元素的频率为 0 时，说明窗口中不存在该元素，若下一个元素的频率为 1 时，说明该元素在窗口中已经存在。</p><p>解题代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># sliding window</span>        freq <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># [left..right] as a sliding window</span>        left <span class="token operator">=</span> res <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> right <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">and</span> freq<span class="token punctuation">[</span>s<span class="token punctuation">[</span>right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                right <span class="token operator">+=</span> <span class="token number">1</span>                freq<span class="token punctuation">[</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                freq<span class="token punctuation">[</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                left <span class="token operator">+=</span> <span class="token number">1</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> resres <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>output <span class="token operator">=</span> res<span class="token punctuation">.</span>lengthOfLongestSubstring<span class="token punctuation">(</span><span class="token string">"abcabcbb"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span></code></pre><p><em>【完】</em></p>]]></content>
      
      
      <categories>
          
          <category> leetcode 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python 3 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第 215 题：数组中的第 k 个最大元素</title>
      <link href="/2019/08/11/QSort/"/>
      <url>/2019/08/11/QSort/</url>
      
        <content type="html"><![CDATA[<h1 id="快速选择算法解决数组中的第-k-个最大元素"><a href="#快速选择算法解决数组中的第-k-个最大元素" class="headerlink" title="快速选择算法解决数组中的第 k 个最大元素"></a>快速选择算法解决数组中的第 k 个最大元素</h1><hr><h3 id="题目来源：LeetCode-第-215-题"><a href="#题目来源：LeetCode-第-215-题" class="headerlink" title="题目来源：LeetCode 第 215 题"></a>题目来源：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">LeetCode 第 215 题</a></h3><p>这道题有三个解法,都是力扣官方题解提供的，我首先想到的前两种，但觉得有点投机取巧，因为是直接调用的python内置函数，一句话就能搞定。力扣官方提供第三种解法，利用经典的快速排序算法的一种变形解决。因为基础不牢，我看了很长时间才弄明白,所以打算写下来加深理解。文章主要介绍第三种解法：</p><blockquote><ol><li><strong>排序：</strong> 先对数组进行排序，然后直接返回倒数第 k 个元素，python中直接使用语句 <code>sorted(nums)[-k]</code> 求出最后结果。算法的时间复杂度为 <code>O(NlogN)</code>，空间复杂度为<code>O(1)</code></li><li><strong>堆：</strong> 创建一个大顶堆，将数组的元素加入到堆中，并保证堆的大小小于等于 k，然后堆中就保留了前 k 个最大元素，这样，堆顶元素就是正确答案。python中有内置的该方法直接求出堆的前 k个最大元素，语句<code>heapq.nlargest(k, nums)[-1]</code>，就可得出最后结果。时间复杂度 : <code>O(Nlogk)</code>，空间复杂度 : <code>O(k)</code>，用于存储堆元素</li></ol></blockquote><h3 id="快速选择算法："><a href="#快速选择算法：" class="headerlink" title="快速选择算法："></a>快速选择算法：</h3><p>快速选择的思路与快速排序一致，选择一个元素作为基准对数组进行分区，使得基准左侧的元素都小于基准的值，右侧的元素都大于基准的值，不同的是，快速选择并不递归访问双边，而是递归到一侧寻找，这使得平均时间复杂度由 <code>O(NlogN)</code> 降低到<code>O(N)</code>。</p><h4 id="python-实现快速排序，分而治之-递归"><a href="#python-实现快速排序，分而治之-递归" class="headerlink" title="python 实现快速排序，分而治之+递归"></a>python 实现快速排序，分而治之+递归</h4><p>对基准两侧分别进行递归操作。选择基准，并申请额外的两个空间，遍历数组，将小于枢轴的元素加入到 left 数组，大于基准的元素加入到 right 数组。</p><p>快速排序代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""QuickSort"""</span>      <span class="token comment" spellcheck="true"># entry and exit  </span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">:</span>                 <span class="token comment" spellcheck="true"># select an element as the pvoit</span>        povit <span class="token operator">=</span> data<span class="token punctuation">[</span>len<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span>               <span class="token comment" spellcheck="true"># define the list to the left and right of the pvoit </span>        left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>          <span class="token comment" spellcheck="true"># remove the povit from the origin list </span>        data<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>povit<span class="token punctuation">)</span>                <span class="token keyword">for</span> num <span class="token keyword">in</span> data<span class="token punctuation">:</span>                        <span class="token keyword">if</span> num <span class="token operator">>=</span> povit<span class="token punctuation">:</span>                                right<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>                        <span class="token keyword">else</span><span class="token punctuation">:</span>                                left<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>                <span class="token keyword">return</span> quick_sort<span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">[</span>povit<span class="token punctuation">]</span> <span class="token operator">+</span> quick_sort<span class="token punctuation">(</span>right<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> data<span class="token comment" spellcheck="true"># example：</span>array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>quick_sort<span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># output = [1, 2, 2, 3, 4, 5, 5, 6, 7, 7, 9, 9, 10, 12, 15, 15, 17]</span></code></pre><h4 id="python-实现快速选择算法"><a href="#python-实现快速选择算法" class="headerlink" title="python 实现快速选择算法"></a>python 实现快速选择算法</h4><p>对基准的一侧进行递归，寻找第 k 个最大的元素。代码中 partition() 函数作用是对数组进行分区，通过以下三步实现：</p><ol><li>将基准移到最右侧；</li><li>将小于基准的数移到 pivot_fix 的左侧；</li><li>将基准移回 pivot_fix 的位置。</li></ol><p>最后该函数返回分区后基准的位置。将位置返回到select()函数中之后，判断该位置是否为 k_smallest(即 len(nums) - k),若是，则返回，若大于 k_smallest，则遍历基准的左侧部分数组，重复之前操作，反之，则遍历基准右侧部分数组，重复之前操作。</p><p>力扣第 215 题解题代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: int        """</span>        <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> pivot_index<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># the value of pivot</span>            pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>pivot_index<span class="token punctuation">]</span>            <span class="token comment" spellcheck="true"># move the pivot to the right of nums</span>            nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>pivot_index<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>pivot_index<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span>            pivot_fix <span class="token operator">=</span> left            <span class="token comment" spellcheck="true"># move the smaller than the value of pivot to the left</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>pivot_fix<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>pivot_fix<span class="token punctuation">]</span>                    pivot_fix <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># move the pivot to the original index</span>            nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>pivot_fix<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>pivot_fix<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span>            <span class="token keyword">return</span> pivot_fix        <span class="token keyword">def</span> <span class="token function">select</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> k_smallest<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token triple-quoted-string string">"""            Returns the k-th smallest element of list within left..right            """</span>            <span class="token keyword">if</span> left <span class="token operator">==</span> right<span class="token punctuation">:</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>            <span class="token comment" spellcheck="true"># select pviot</span>            pivot_index <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>            pivot_index <span class="token operator">=</span> partition<span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">,</span>pivot_index<span class="token punctuation">)</span>            <span class="token keyword">if</span> pivot_index <span class="token operator">==</span> k_smallest<span class="token punctuation">:</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>pivot_index<span class="token punctuation">]</span>            <span class="token comment" spellcheck="true"># do left</span>            <span class="token keyword">elif</span> pivot_index <span class="token operator">></span> k_smallest<span class="token punctuation">:</span>                <span class="token keyword">return</span> select<span class="token punctuation">(</span>left<span class="token punctuation">,</span>pivot_index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>k_smallest<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># do right</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> select<span class="token punctuation">(</span>pivot_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>k_smallest<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># kth largest is (n - k)th smallest</span>        <span class="token keyword">return</span> select<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> k<span class="token punctuation">)</span>res <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>output <span class="token operator">=</span> res<span class="token punctuation">.</span>findKthLargest<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span></code></pre><p><em>【完】</em></p>]]></content>
      
      
      <categories>
          
          <category> leetcode 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python 3 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一本叫 《骆驼祥子》 的书</title>
      <link href="/2019/07/29/mood1/"/>
      <url>/2019/07/29/mood1/</url>
      
        <content type="html"><![CDATA[<h1 id="祥子：一个时代的牺牲者"><a href="#祥子：一个时代的牺牲者" class="headerlink" title="祥子：一个时代的牺牲者"></a>祥子：一个时代的牺牲者</h1><hr><pre class=" language-1"><code class="language-1">这本书是老舍在七七事变那一年写成的，一九四五年，此书在美国被译成英文，但将末端删去了，把悲剧的下场改为了大团圆，以便迎合美国读者的心理。</code></pre><p>&emsp;&emsp;祥子的故事从骆驼说起，自己的新车转眼间变成了三匹骆驼这让祥子很不甘心，他想要一辆自己的车！祥子的命运始终和车绑在一起，几经沉浮，祥子自己也体会到了人在社会身不由己，生活可不像拉车这么容易。穷人的梦想也只能是梦想，最后祥子向生活妥协，堕落……</p><p>&emsp;&emsp;有人说 《骆驼祥子》 是在讲：</p><blockquote><ul><li>无产阶级被资产阶级压榨的故事</li><li>个人主义在中国如何行不通的故事</li><li>平凡人的努力不一定能够成功的故事</li></ul></blockquote><p>&emsp;&emsp;对于我而言，《骆驼祥子》 也有我们影子。</p><p>&emsp;&emsp;祥子的感受就是我的感受。祥子第一次攒够钱买到车时，我欢喜。他为了多攒几块钱冒险拉车而被抢了车时，我懊悔。他被别人欺负时，我生气。“人为刀俎，我为鱼肉”就是这类社会底层人的真实写照，善良、简单、诚实的祥子一次次被生活暴击，活着看似很痛苦。</p><p>&emsp;&emsp;前段时间读余华的《活着》， 为福贵的悲惨命运难受了一阵子。他们都是在生活越来越有奔头的时候遭受重大打击，上天总是给了他们很多希望，然后又摧毁他们的希望。不一样的是福贵在一次次得失中看淡了命运的不公，平凡的度过余生，而祥子却放弃了自己，行尸走肉般活着。</p><blockquote><p>好吧，老实，规矩，要强，既然都没有用，变成这样的无赖也不错</p></blockquote><p>&emsp;&emsp;他活成了自己最讨厌的样子。<br>&emsp;&emsp;他的人生起起落落，一次次重拾希望，又一次次遭受希望破灭的打击，让人看着也跟着揪心。<br>&emsp;&emsp;好不容易攒够了钱买了车，被抢走了；再次攒钱买车，还没攒够，钱被骗走了；娶了老婆，老婆难产而死。车没了，家没了，一切又回到原点。他堕落了很长一段时间，最后打起精神要好好生活，去找曹先生，曹先生为他安排好工作，也答应为他心上人小福子安排吃住，这是他最后燃起的希望。他满心欢喜地期待着把小福子接过来。他回到之前的小院，却怎么也找不到小福子，多方打听之后才知道她被父亲卖到了妓院，等他找到那个妓院后，小福子已经自杀了。小福子的自杀，使他丧失了所有的期待和幻想，他再也不敢期盼未来，再也没有动力去追逐理想的生活，再也不愿付出努力了。他还活着，但心已经死了，空留着一副皮囊苟活于世。<br>&emsp;&emsp;想毁掉一个人太简单了，只要让他的梦想不断地破灭即可。</p><blockquote><p>穷人的命，他似乎看明白了，是枣核儿的两头尖：幼小的时候能不饿死，万幸；到老了能不饿死，很难。只有中间的一段，年轻力壮，不怕饥饱劳碌，还能像个人儿似的。</p></blockquote><p>&emsp;&emsp;老舍的比喻总是那么精确，只言片语便道出了那个时期底层人民的状态。年轻力壮总是好过的，童年和老年就是两个最无奈的时期。没有生存的能力，又不能忍受饥饱劳碌。社会在变化，就如今而言，这个比喻也相当贴切。把人生比作枣核，枣核两头尖代表人生的童年和老年，真正有深度有意义的还是枣核的中间部分，年轻力壮，大有可为。但人总是在最好时光做自己后悔的事，或者说在自己无力与时光相耗时，又难掩悲伤。</p><blockquote><p>爱与不爱，穷人得在金钱上决定，“情种”只生在大富之家</p></blockquote><p>&emsp;&emsp;钱不是万能的，但对于穷人来说，钱几乎就是生活的全部，或者说穷人的生活是围着钱转的。有金钱作为基础，爱情或许才会更美好。</p><h3 id="《骆驼祥子》-经典语句摘录："><a href="#《骆驼祥子》-经典语句摘录：" class="headerlink" title="《骆驼祥子》 经典语句摘录："></a>《骆驼祥子》 经典语句摘录：</h3><blockquote><ol><li>苦人的懒是努力而落了空的自然结果，苦人的耍刺儿含着一些公理</li><li>人间的真话本来不多，一个女子的脸红胜过一大片话</li><li>爱与不爱，穷人得再金钱上决定，“情种”只生在大富之家</li><li>越不肯努力便越自怜</li><li>懒，能使人脾气变大</li><li>经验是生活得肥料，有什么样得经验便变成什么样的人，在沙漠里养不出牡丹来</li><li>在不准知道事情的吉凶的时候，人总是先往好里想</li><li>为个人努力的也知道如何毁灭个人，这是个人主义的两端</li><li>乱世的热闹来自迷信，愚人的安慰只有自欺</li><li>懂行的人得到个便宜，就容易忘掉东西买到手有没有好处</li><li>什么也是假的，只有钱是真的</li><li>常将有日思无日，莫到无时盼有时</li><li>一个人仿佛根本什么都不是，只是一只鸟，自己去打食，便会落到网里。吃人家的粮米，便得老老实实地在笼子里，给人家啼唱，而随时可以被人卖掉</li><li>一个天真的，发自内心的笑，仿佛把以前的困苦全一笔勾销，而笑着换个新的世界，像换一件衣服那么容易，痛快</li><li>最伟大的牺牲时忍辱，最伟大的忍辱时预备反抗</li><li>苦人是容易死的，苦人死了是容易被人忘掉的</li><li>疲乏之后的安息是最甜美的享受</li></ol></blockquote><p><em>【完】</em></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>边充电边玩手机会爆炸么</title>
      <link href="/2019/07/29/phone1/"/>
      <url>/2019/07/29/phone1/</url>
      
        <content type="html"><![CDATA[<h1 id="边玩手机边充电真的会爆炸么"><a href="#边玩手机边充电真的会爆炸么" class="headerlink" title="边玩手机边充电真的会爆炸么"></a>边玩手机边充电真的会爆炸么</h1><hr><blockquote><p><strong>结论</strong> ： 使用正规充电器，手机边玩边充电发生爆炸的几率几乎为零。需要注意的是：第一、充电尽量使用原装充电器。第二、不随意搭配充电设备。第三、充电环境温度要适宜。第四、及时清理充电口。第五、尽量不要边玩边充电。</p></blockquote><h3 id="手机爆炸是怎么发生的"><a href="#手机爆炸是怎么发生的" class="headerlink" title="手机爆炸是怎么发生的"></a>手机爆炸是怎么发生的</h3><p>我们通常说的边玩手机边充电、边打电话边充电会发生危险，一般都是指电池的爆炸。</p><blockquote><ol><li>从手机充电的电路设计角度来看，在充电过程中使用手机，手机运行程序所需的电能来源于电源而非电池，这时电池充电跟手机的使用是分开的，互不影响。</li><li>电池充满电后，会停止充电。并且由于电池端电压小于外接电路的电压，电池也不会放电。</li><li>充电状态下的手机可以作为一个正常的电器使用，一般不会发生爆炸，<strong>使用正规充电器，手机边玩边充电发生爆炸的几率几乎为零。</strong>但是如果使用的是劣质或者山寨的充电器，很有可能因为质量不过关，出现手机电路不稳定，造成电池异常发热，导致手机有可能发生爆炸。</li></ol></blockquote><p>大家可能经常从电视上或者新闻中，看到不少因为边充电边玩手机的原因而导致手机爆炸的问题，其实这个问题和电池是没有关系的，主要还是因为充电时使用了不匹配的充电器，或者是第三方充电器。更有甚者，是手机在出厂时，电池就有问题，存在着安全隐患，一般情况下是不会有这种事情发生的。</p><h3 id="怎样充电更安全"><a href="#怎样充电更安全" class="headerlink" title="怎样充电更安全"></a>怎样充电更安全</h3><blockquote><ol><li><strong>充电尽量使用原装充电器。</strong>非原装充电器可能会出现手机充电缓慢、损坏电池的情况。如果使用劣质充电器，还有可能造成安全隐患。</li><li><strong>不随意搭配充电设备。</strong>充电器与USB充电线混用，很可能会导致充电速度变慢，无法给手机充电的情况。为手机充电时建议选择与手机电流适配的充电设备进行充电。</li><li><strong>充电环境温度要适宜。</strong>在低温环境下，锂电池的低温保护机制会使得手机电池不发生化学反应，从而导致充电缓慢的情况发生。温度过高的环境中充电很可能会损失锂电池，造成安全隐患。</li><li><strong>及时清理充电口。</strong>充电口长时间暴露在外面，会产生灰尘堆积，导致手机充电接触不良，影响充电速度。记得定期清洁手机充电口，一笔米娜出现灰尘堵塞。</li><li><strong>尽量不要边玩边充电。</strong>边玩边充电会加剧手机发热。手机长时间处于这种状态，会导致手机寿命急剧缩短，严重时甚至会引发火灾。如果必须边玩边充电，应注意观察手机的情况，一旦出现高温异常，应立即停止操作。</li></ol></blockquote><p><em>【完】</em></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第 46 题：全排列</title>
      <link href="/2019/07/23/79th/"/>
      <url>/2019/07/23/79th/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-回溯法专题"><a href="#LeetCode-回溯法专题" class="headerlink" title="LeetCode 回溯法专题"></a>LeetCode 回溯法专题</h1><hr><h3 id="题目来源：LeetCode-第-46-题"><a href="#题目来源：LeetCode-第-46-题" class="headerlink" title="题目来源：LeetCode 第 46 题"></a>题目来源：<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">LeetCode 第 46 题</a></h3><blockquote><p><strong>回溯法</strong> 是一种在探索尝试的过程中来找出所有解的算法。当确定这个候选解不满足求解条件时，就’回溯’返回，尝试其他路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术就叫回溯法。</p></blockquote><h6 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h6><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">permute</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: List[List[int]]        """</span>        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index <span class="token operator">==</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>                output<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">return</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token operator">not</span> used<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    p<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>                    backtrack<span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span>                    used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>                    p<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        output <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> <span class="token operator">not</span> nums<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        used <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span> <span class="token operator">*</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        backtrack<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> output</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯法 </tag>
            
            <tag> python 3 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
